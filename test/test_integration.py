"""Integration tests for emotional-decoration system with scroll-cast compatibility."""

import pytest
import tempfile
import shutil
from pathlib import Path
import sys

# Add src to path for testing
sys.path.insert(0, str(Path(__file__).parent.parent / "src"))

from emotional_decoration.orchestrator.decoration_engine import DecorationEngine
from emotional_decoration.models import DecorationRequest
from emotional_decoration.themes.theme_loader import ThemeLoader


class TestScrollCastIntegration:
    """Test integration with scroll-cast CSS override architecture."""
    
    @pytest.fixture
    def temp_dir(self):
        """Create temporary directory for test outputs."""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        shutil.rmtree(temp_dir)
    
    @pytest.fixture
    def engine(self, temp_dir):
        """Create decoration engine with temporary output directory."""
        return DecorationEngine(temp_dir)
    
    @pytest.fixture
    def sample_scroll_cast_html(self):
        """Sample HTML generated by scroll-cast."""
        return """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scroll Cast Demo</title>
    <link rel="stylesheet" href="scrollcast-core.css">
</head>
<body>
    <div class="typewriter-container">
        <div class="typewriter-sentence">
            <span class="typewriter-char">H</span>
            <span class="typewriter-char">e</span>
            <span class="typewriter-char">l</span>
            <span class="typewriter-char">l</span>
            <span class="typewriter-char">o</span>
            <span class="typewriter-char"> </span>
            <span class="typewriter-char">W</span>
            <span class="typewriter-char">o</span>
            <span class="typewriter-char">r</span>
            <span class="typewriter-char">l</span>
            <span class="typewriter-char">d</span>
        </div>
    </div>
    <script src="scrollcast-core.js"></script>
</body>
</html>"""
    
    def test_basic_decoration_generation(self, engine):
        """Test basic decoration generation functionality."""
        text = "Hello World! This is an educational content about learning new skills."
        
        # Create decoration request
        request = DecorationRequest(
            text=text,
            template_type="typewriter",
            theme_preference="learning",
            output_format="css"
        )
        
        # Process request
        response = engine.process_decoration_request(request)
        
        # Verify response
        assert response.success
        assert response.output.css_content
        assert response.analysis.profile.content_type.value == "learning"
        assert "decoration-enhanced" in response.output.css_content
        assert "--decoration-primary-start" in response.output.css_content
    
    def test_css_override_compatibility(self, engine):
        """Test that generated CSS follows override architecture."""
        text = "Professional business presentation content for corporate audience."
        
        decoration_output = engine.generate_theme_only(text, "typewriter", "professional")
        css_content = decoration_output.css_content
        
        # Check for CSS custom properties
        assert "--decoration-primary-start:" in css_content
        assert "--decoration-primary-end:" in css_content
        assert "--decoration-glow-intensity:" in css_content
        
        # Check for proper selector structure
        assert ".typewriter-char {" in css_content
        assert "background: linear-gradient(" in css_content
        assert "-webkit-background-clip: text;" in css_content
        
        # Ensure no conflicts with core functionality
        assert "opacity:" not in css_content.split(".typewriter-char {")[1].split("}")[0]
        assert "transition:" not in css_content.split(".typewriter-char {")[1].split("}")[0]
        assert "display:" not in css_content.split(".typewriter-char {")[1].split("}")[0]
    
    def test_html_injection_preserves_structure(self, engine, sample_scroll_cast_html, temp_dir):
        """Test that HTML injection preserves scroll-cast structure."""
        # Save sample HTML to file
        html_file = Path(temp_dir) / "test.html"
        html_file.write_text(sample_scroll_cast_html)
        
        text = "This is a sample text for testing HTML injection capabilities."
        
        # Enhance HTML file
        enhanced_file = engine.enhance_html_file(
            str(html_file), 
            text, 
            template_type="typewriter"
        )
        
        # Read enhanced HTML
        enhanced_content = Path(enhanced_file).read_text()
        
        # Verify original structure is preserved
        assert '<div class="typewriter-container">' in enhanced_content
        assert '<span class="typewriter-char">H</span>' in enhanced_content
        assert 'scrollcast-core.css' in enhanced_content
        assert 'scrollcast-core.js' in enhanced_content
        
        # Verify decoration is added
        assert 'EMOTIONAL-DECORATION-CSS-START' in enhanced_content
        assert 'EMOTIONAL-DECORATION-CSS-END' in enhanced_content
        assert '--decoration-primary-start' in enhanced_content
        assert 'decoration-enhanced' in enhanced_content
    
    def test_theme_loader_integration(self):
        """Test theme loader integration with predefined themes."""
        theme_loader = ThemeLoader()
        
        # Test loading predefined themes
        themes = theme_loader.list_themes()
        assert len(themes) > 0
        
        # Test specific theme loading
        learning_theme = theme_loader.get_theme("learning_focused")
        if learning_theme:  # Only test if theme file exists
            assert learning_theme.name == "Learning Focused"
            assert learning_theme.colors.primary_start == "#4A90E2"
            assert "typewriter" in learning_theme.compatibility
    
    def test_multiple_template_compatibility(self, engine):
        """Test compatibility across different scroll-cast templates."""
        text = "Sample content for testing multiple template compatibility."
        
        templates = ["typewriter", "railway", "scroll"]
        
        for template in templates:
            decoration_output = engine.generate_theme_only(text, template)
            css_content = decoration_output.css_content
            
            # Check template-specific CSS classes
            if template == "typewriter":
                assert ".typewriter-char" in css_content
                assert ".typewriter-container" in css_content
            elif template == "railway":
                assert ".railway-line" in css_content or ".typewriter-char" in css_content
            elif template == "scroll":
                assert ".scroll-line" in css_content or ".typewriter-char" in css_content
            
            # Verify CSS variables are present
            assert "--decoration-primary-start" in css_content
            assert "--decoration-glow-intensity" in css_content
    
    def test_performance_requirements(self, engine):
        """Test that system meets performance requirements."""
        # Test with various text sizes
        test_texts = [
            "Short text.",
            "Medium length text that contains several sentences and covers multiple topics including learning, emotions, and professional content.",
            "Long text content " * 100  # ~1400 characters
        ]
        
        for text in test_texts:
            start_time = time.time()
            
            request = DecorationRequest(
                text=text,
                template_type="typewriter",
                output_format="css"
            )
            
            response = engine.process_decoration_request(request)
            processing_time = time.time() - start_time
            
            # Calculate characters per second
            chars_per_second = len(text) / processing_time if processing_time > 0 else 0
            
            # Should be able to process at least 1000 chars/sec (target: 5000)
            assert chars_per_second > 1000, f"Processing speed too slow: {chars_per_second:.0f} chars/sec"
            assert response.success
    
    def test_css_validation(self, engine):
        """Test that generated CSS is valid and well-formed."""
        text = "Test content for CSS validation."
        
        decoration_output = engine.generate_theme_only(text, "typewriter")
        css_content = decoration_output.css_content
        
        # Basic CSS syntax validation
        open_braces = css_content.count("{")
        close_braces = css_content.count("}")
        assert open_braces == close_braces, "Mismatched CSS braces"
        
        # Check for required CSS properties
        assert "background:" in css_content or "background-image:" in css_content
        assert "filter:" in css_content or "box-shadow:" in css_content
        
        # Check for CSS custom properties format
        custom_props = [line.strip() for line in css_content.split("\\n") if line.strip().startswith("--decoration-")]
        assert len(custom_props) > 0, "No CSS custom properties found"
        
        for prop in custom_props:
            assert ":" in prop, f"Invalid CSS property format: {prop}"
            assert ";" in prop, f"Missing semicolon in CSS property: {prop}"
    
    def test_theme_consistency(self, engine):
        """Test that themes produce consistent results."""
        text = "Consistent test content for theme validation."
        
        # Generate same theme multiple times
        results = []
        for _ in range(3):
            decoration_output = engine.generate_theme_only(text, "typewriter", "learning")
            results.append(decoration_output.theme_config.colors.primary_start)
        
        # All results should be identical
        assert all(color == results[0] for color in results), "Theme generation is not consistent"
    
    def test_error_handling(self, engine, temp_dir):
        """Test error handling in various scenarios."""
        # Test with empty text
        request = DecorationRequest(
            text="",
            template_type="typewriter"
        )
        response = engine.process_decoration_request(request)
        # Should handle gracefully, even if not successful
        assert response is not None
        
        # Test with invalid HTML file
        invalid_html = Path(temp_dir) / "invalid.html"
        invalid_html.write_text("Not valid HTML content")
        
        # Should not crash
        try:
            validation = engine.validate_html_compatibility(str(invalid_html))
            assert validation is not None
        except Exception as e:
            pytest.fail(f"Error handling failed: {e}")


if __name__ == "__main__":
    import time
    pytest.main([__file__, "-v"])